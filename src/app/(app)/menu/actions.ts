
"use server";

import { db } from "@/lib/firebase";
import { collection, writeBatch, doc, addDoc, updateDoc, deleteDoc } from "firebase/firestore";
import { revalidatePath } from "next/cache";
import { mockRecipes, mockRecipeIngredients } from "@/data/mock-data";
import { Recipe } from "@/data/definitions";

export async function saveDish(formData: FormData) {
    const id = formData.get('id') as string;
    
    try {
        const data: Omit<Recipe, 'id' | 'tags' | 'procedure' | 'allergens'> & { tags: string[], procedure: object, allergens: string[] } = {
            name: formData.get('name') as string,
            description: formData.get('description') as string,
            category: formData.get('category') as string,
            price: parseFloat(formData.get('price') as string),
            cost: 0, // Will be updated from recipe cost page
            image: formData.get('image') as string || 'https://placehold.co/600x400.png',
            imageHint: '', // Can be generated by AI if needed
            prepTime: parseInt(formData.get('prepTime') as string),
            difficulty: parseInt(formData.get('difficulty') as string) as Recipe['difficulty'],
            status: formData.get('status') as Recipe['status'],
            tags: JSON.parse(formData.get('tags') as string || '[]'),
            procedure: { preparation: [], cuisson: [], service: [] }, // Default, updated on cost page
            allergens: [], // Default, can be updated
        };

        if (id) {
            // Update existing recipe
            const docRef = doc(db, "recipes", id);
            await updateDoc(docRef, data);
        } else {
            // Create new recipe
            await addDoc(collection(db, "recipes"), data);
        }

        revalidatePath("/menu");
        return { success: true, message: `Plat "${data.name}" sauvegardé.` };

    } catch (error) {
        console.error("Error saving dish:", error);
        const errorMessage = error instanceof Error ? error.message : String(error);
        return { success: false, message: `Erreur lors de la sauvegarde : ${errorMessage}` };
    }
}


export async function deleteDish(id: string) {
    try {
        const docRef = doc(db, "recipes", id);
        await deleteDoc(docRef);
        
        revalidatePath("/menu");
        return { success: true, message: "Plat supprimé avec succès." };
    } catch (error) {
        console.error("Error deleting dish:", error);
        const errorMessage = error instanceof Error ? error.message : String(error);
        return { success: false, message: `Erreur lors de la suppression : ${errorMessage}` };
    }
}


export async function seedRecipes() {
  try {
    const batch = writeBatch(db);

    const recipesCollection = collection(db, "recipes");
    mockRecipes.forEach((recipe) => {
      // Create a new object excluding fields we don't want in Firestore
      const {
        cost: mockCost, // remove mock cost
        imageAltText,
        cookTime,
        totalTime,
        servings,
        portionDescription,
        nutritionalInfo,
        instructions,
        marketingDescription,
        equipment,
        chef,
        createdAt,
        updatedAt,
        ...recipeToStore
      } = recipe;

      const docData: Omit<Recipe, 'id'> = {
          ...recipeToStore,
          cost: 0, // Initialize cost to 0
          image: `https://placehold.co/600x400.png?text=${encodeURIComponent(recipe.name)}`
      };

      const docRef = doc(recipesCollection, recipe.id);
      batch.set(docRef, docData);
    });

    const recipeIngredientsCollection = collection(db, "recipeIngredients");
    mockRecipeIngredients.forEach((ri) => {
      const docRef = doc(recipeIngredientsCollection, ri.id);
      batch.set(docRef, ri);
    });

    await batch.commit();
    
    revalidatePath("/menu");
    revalidatePath("/recipe-cost");

    return { success: true, message: `${mockRecipes.length} recettes ont été ajoutées.` };
  } catch (error) {
    console.error("Error seeding recipes:", error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    return { success: false, message: `Erreur lors de l'initialisation : ${errorMessage}` };
  }
}
