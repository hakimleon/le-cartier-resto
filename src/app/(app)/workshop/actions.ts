
'use server';

import { collection, addDoc, query, where, getDocs, writeBatch, doc } from 'firebase/firestore';
import { db } from '@/lib/firebase';
import type { Preparation, Recipe } from '@/lib/types';
import type { DishConceptOutput } from '@/ai/flows/workshop-flow';

/**
 * Creates a new dish (recipe of type 'Plat') from a concept generated by the workshop AI.
 * It attempts to link suggested sub-recipes to existing preparations, or creates new empty preparations if they don't exist.
 * @param concept - The dish concept generated by the AI.
 * @returns The ID of the newly created dish.
 */
export async function createDishFromWorkshop(concept: DishConceptOutput): Promise<string> {
    try {
        const dishData: Omit<Recipe, 'id'> = {
            type: 'Plat',
            name: concept.name,
            description: concept.description,
            imageUrl: concept.imageUrl,
            procedure_preparation: concept.procedure_preparation,
            procedure_cuisson: concept.procedure_cuisson,
            procedure_service: concept.procedure_service,
            difficulty: concept.difficulty,
            duration: concept.duration,
            portions: concept.portions,
            commercialArgument: concept.commercialArgument,
            price: 0, 
            status: 'Inactif',
            category: 'Plats et Grillades',
            tvaRate: 10,
        };

        const recipesCol = collection(db, 'recipes');
        const recipeDocRef = await addDoc(recipesCol, dishData);
        const newDishId = recipeDocRef.id;

        // Handle sub-recipes linking and creation
        if (concept.subRecipes && concept.subRecipes.length > 0) {
            const preparationsCol = collection(db, 'preparations');
            const batch = writeBatch(db);

            // Fetch all preparations that match the names suggested by the AI
            const q = query(preparationsCol, where('name', 'in', concept.subRecipes));
            const querySnapshot = await getDocs(q);
            
            const foundPreparations: Preparation[] = [];
            querySnapshot.forEach(doc => {
                foundPreparations.push({ id: doc.id, ...doc.data() } as Preparation);
            });

            const foundPrepNames = foundPreparations.map(p => p.name);
            const newPrepNames = concept.subRecipes.filter(name => !foundPrepNames.includes(name));

            // Link existing preparations
            foundPreparations.forEach(prep => {
                const linkRef = doc(collection(db, 'recipePreparationLinks'));
                batch.set(linkRef, {
                    parentRecipeId: newDishId,
                    childPreparationId: prep.id,
                    quantity: 1, // Default quantity, user must adjust
                    unitUse: prep.usageUnit || prep.productionUnit || 'g',
                });
            });

            // Create and link new (empty) preparations
            for (const newName of newPrepNames) {
                // Create the new preparation document
                const newPrepRef = doc(collection(db, 'preparations'));
                const newPrepData: Omit<Preparation, 'id'> = {
                    type: 'Préparation',
                    name: newName,
                    description: `Préparation pour "${concept.name}" générée par l'atelier.`,
                    difficulty: 'Moyen',
                    duration: 15,
                    productionQuantity: 1,
                    productionUnit: 'kg',
                    usageUnit: 'g',
                    procedure_preparation: '',
                    procedure_cuisson: '',
                    procedure_service: '',
                };
                batch.set(newPrepRef, newPrepData);
                
                // Create the link to this new preparation
                const linkRef = doc(collection(db, 'recipePreparationLinks'));
                batch.set(linkRef, {
                    parentRecipeId: newDishId,
                    childPreparationId: newPrepRef.id,
                    quantity: 1,
                    unitUse: newPrepData.usageUnit || newPrepData.productionUnit,
                });
            }

            await batch.commit();
        }
        
        return newDishId;

    } catch (error) {
        console.error("Error creating dish from workshop:", error);
        if (error instanceof Error) {
            throw new Error(`Failed to create dish: ${error.message}`);
        }
        throw new Error("An unknown error occurred while creating the dish from the workshop concept.");
    }
}
